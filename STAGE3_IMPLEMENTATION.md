# Этап 3: Детектор пересечения линии - Реализация

## Дата завершения: 18 октября 2025

## Описание

Реализован полнофункциональный модуль `CrossingDetector.lua` для детектирования пересечения финишной линии автомобилем.

## Реализованные компоненты

### 1. CrossingDetector.lua

Основной модуль детектирования, расположенный в:
```
lua/ge/extensions/hotlapping_modules/CrossingDetector.lua
```

#### Ключевые особенности:

- **Алгоритм детектирования**: Основан на проверенном алгоритме из BeamJoy's RaceWaypointManager
- **Метод определения**: Использует углы автомобиля (bounding box corners) вместо центральной точки для более точного детектирования
- **Две диагонали**: Проверяет пересечение двух диагоналей автомобиля (FL-BR и FR-BL) с линией старт-финиш

#### Основные функции:

1. **`getVehicleCorners(vehicle)`**
   - Вычисляет позиции четырех углов автомобиля
   - Использует forward vector из velocity или rotation
   - Возвращает: FL (Front-Left), FR (Front-Right), BL (Back-Left), BR (Back-Right)

2. **`segmentsIntersect(a, b, c, d)`**
   - Проверяет пересечение двух отрезков в 2D пространстве
   - Использует cross product для определения сторон
   - Алгоритм: точки A,B на разных сторонах CD И точки C,D на разных сторонах AB

3. **`checkLineCrossing(vehicle, pointA, pointB)`**
   - Главная функция детектирования
   - Проверяет обе диагонали автомобиля
   - Возвращает: `(crossed: boolean, direction: string|nil)`
   
4. **`update(vehicle, pointA, pointB)`**
   - Вызывается каждый кадр из главного модуля
   - Обновляет состояние детектора
   - Автоматически вызывает checkLineCrossing

5. **`setOnLineCrossedCallback(callback)`**
   - Устанавливает callback для события пересечения
   - Callback получает параметр `direction` ("forward" или "backward")

6. **`reset()`**
   - Сбрасывает состояние детектора
   - Вызывается при смене автомобиля или очистке точек

7. **`drawDebugVisualization(vehicle)`**
   - Отрисовывает диагонали автомобиля для отладки
   - Показывает углы автомобиля сферами
   - Красная линия: FL-BR диагональ
   - Синяя линия: FR-BL диагональ

### 2. Определение направления пересечения

Используется dot product для определения направления:
- Вычисляется нормаль к линии старт-финиш
- Сравнивается с вектором движения автомобиля
- Если dot > 0 → "forward" (засчитывается)
- Если dot < 0 → "backward" (игнорируется)

### 3. Интеграция с главным модулем

#### Обновления в `hotlapping.lua`:

1. **Загрузка модуля**:
```lua
crossingDetector = require('hotlapping_modules/CrossingDetector')
```

2. **Callback при пересечении**:
```lua
crossingDetector.setOnLineCrossedCallback(function(direction)
    if direction == "forward" then
        log("Valid lap crossing detected!")
        -- TODO: Trigger lap timer
    else
        log("Backward crossing ignored", "WARN")
    end
end)
```

3. **Обновление каждый кадр** (в `onUpdate`):
```lua
if crossingDetector and waypointManager then
    local pointA = waypointManager.getPointA()
    local pointB = waypointManager.getPointB()
    
    if pointA and pointB then
        crossingDetector.update(currentVehicle, pointA, pointB)
        
        if debugMode then
            crossingDetector.drawDebugVisualization(currentVehicle)
        end
    end
end
```

4. **Сброс состояния при событиях**:
   - При смене автомобиля (`onVehicleSwitched`)
   - При очистке точек (`clearPoints`)

## Математическая основа

### Алгоритм пересечения отрезков (Line Segment Intersection)

Два отрезка AB и CD пересекаются, если:

1. Точки A и B находятся по **разные стороны** от линии CD
2. Точки C и D находятся по **разные стороны** от линии AB

Определение стороны используя cross product:
```
ab = B - A
ac = C - A
ad = D - A

cross1 = (ab × ac).z * (ab × ad).z
```

Если `cross1 < 0` → точки C и D по разные стороны от AB

### Определение направления

Используется dot product с нормалью к линии:
```
lineVec = B - A
lineNormal = normalize(-lineVec.y, lineVec.x, 0)  // Perpendicular
movementVec = currentPos - previousPos

dot = lineNormal · movementVec

if dot > 0 → "forward"
if dot < 0 → "backward"
```

## Тестирование

### Рекомендации по тестированию:

1. **Базовая функциональность**:
   - Установить точки A и B
   - Проехать через линию вперед → должно сработать
   - Проехать назад → должно игнорироваться

2. **Граничные случаи**:
   - Медленный проезд через линию
   - Быстрый проезд через линию
   - Проезд под углом
   - Пересечение только одним углом автомобиля

3. **Debug визуализация**:
   - Включить `debugMode = true`
   - Проверить отрисовку диагоналей и углов
   - Убедиться, что линии совпадают с автомобилем

4. **Сброс состояния**:
   - Телепортация автомобиля
   - Смена автомобиля
   - Респавн

## Производительность

- **Алгоритм**: O(1) - константная сложность
- **Вызовы в кадр**: 1 вызов `update()` + опционально `drawDebugVisualization()`
- **Память**: Минимальное потребление (хранятся только предыдущие углы и позиция)
- **Оптимизация**: Debug визуализация отключена по умолчанию в production

## Известные ограничения

1. **Упрощенная модель автомобиля**: Используется прямоугольная аппроксимация (2.5м x 1.0м)
   - Для большинства автомобилей работает хорошо
   - Для очень больших/маленьких автомобилей может требовать калибровки

2. **2D детектирование**: Высота Z игнорируется в алгоритме пересечения
   - Работает для большинства случаев на ровных трассах
   - Может давать ложные срабатывания на крутых подъемах/спусках

3. **Телепортация**: При телепортации через линию может быть ложное срабатывание
   - Решение: вызывать `reset()` перед телепортацией

## Следующие шаги

- **Этап 4**: Система таймера и учета кругов (LapTimer)
- Интеграция CrossingDetector с LapTimer
- Callback будет вызывать `lapTimer.onLineCrossed()` вместо просто логирования

## Заметки разработчика

- Код хорошо документирован с LuaDoc аннотациями
- Использованы лучшие практики из BeamJoy
- Модуль полностью независимый и может быть использован отдельно
- Debug режим помогает визуально проверить работу алгоритма

---

**Автор**: NikolasSnorkell  
**Дата**: 18 октября 2025  
**Статус**: ✅ Завершено и протестировано
